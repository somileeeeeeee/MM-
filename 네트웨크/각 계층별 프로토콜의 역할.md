# 각 계층별 프로토콜의 역할.md
## 리눅스 환경 구축
- 윈도우 WSL을 이용해 구축해보기
  - 커맨드(관리자)창을 통해 리눅스 서브시스템 지원 활성화
```CMD
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
```
![image](https://user-images.githubusercontent.com/30613069/185810841-7b7ad684-a17a-4181-8cef-03153a2f5a7b.png)

-> 이제 리눅스 서브시스템을 사용하기 위한 준비 완료

- WSL2를 사용하기 위해 윈도우 업데이트 설치
- WSL 기본 버전을 2로 변경
```CMD
wsl --set-default-version 2
```

- MS 스토어에서 우분투, 윈도우 터미널 설치
![image](https://user-images.githubusercontent.com/30613069/185810889-9c14dc67-1607-4932-897d-e1fb2c3d63cd.png)
> 최신 버전 22.04.04 설치

![image](https://user-images.githubusercontent.com/30613069/185810989-f0af4204-3947-44f7-a871-0ddf44b5ea43.png)
![image](https://user-images.githubusercontent.com/30613069/185810994-7cc693a7-cf31-4f02-8311-72ac861eb758.png)
> 버전 확인

- apt-get 패키지들
```cmd
sudo apt update
sudo apt install git zsh
sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

## 1. 네트워크 디바이스와 드라이버 (이더넷)
### NIC(Network Interface Controller)
- 네트워크 장비와 LAN 사이의 통신을 준비
- 전송될 데이터를 병렬에서 직렬로 전환
- 빠른 전송을 위해 데이터를 코딩 및 압축
- 목적지 장비는 NIC 는 데이터를 수신하고 CPU 로 데이터를 전달
- Access Control 기능이 구현된 하드웨어와 펌웨어(소프트웨어)가 들어 있다.
* 하드웨어는 2가지 형태의 저장소가 있는데, 제어를 위한 제어레지스터, 저장만을 위한 저장레지스터가 있음.

### 연결 방식
- 유선 혹은 무선으로 설계될 수 있다.
- 이더넷, 기가비트 이더넷, 광섬유, 토큰링..

## 네트워크 칩의 예
### CS8900A 특징
- Cyrus Logic 에서 개발된 10Mbps(bits/sec)를 지원하는 Ethernet Controller
- IEEE 802.3 기준을 따르고 Direct ISA-Bus 연결을 사용한다
- 10BASE-T와 10BASE2, 10BASE5, 10BASE-F를 지원하기 위한 AUI(Attachment Unit Interface)를 가지고 있다
- disk가 없는 시스템의 booting을 위한 Boot PROM 지원.
- Tx시에는 collision이 있을 때, 자동적인 재전송 및 Padding과 CRC 생성을 해준다.
- Rx시에는 CPU의 overhead를 줄이기 위해서 StreamTransfer를 제공
- I/O및 메모리 공간과 DMA slave로서 동작할 때 사용하기 위한 Packet Page
- EEPROM을 제공하여 점퍼설정을 최소화한 설정이 가능
![image](https://user-images.githubusercontent.com/30613069/186028136-e61bdaac-08a3-497e-9d0c-4b838c85bc52.png)

## CSMA/CD (충돌 처리) 기본 알고리즘
![image](https://user-images.githubusercontent.com/30613069/186028235-a143d6d9-9564-423d-b447-d552e7a1d72b.png)

- CSMA/CD 두가지 옵션
![image](https://user-images.githubusercontent.com/30613069/186028537-73360529-a415-4f6b-87d5-99049e0b9a27.png)

## 이더넷의 계층 구조
- LLC : 흐름제어와 오류 제어를 담당
- MAC ; CSMA/CD 접근 방법에 대한 동작을 담당
![image](https://user-images.githubusercontent.com/30613069/186029513-daa59bbc-0c8c-4e83-8b61-dfc78d7dd22d.png)

## 이더넷 프레임(Frame) 포멧
![image](https://user-images.githubusercontent.com/30613069/186029566-c7952cf7-0dea-4822-92b9-fd74523676eb.png)

- 프레임 Encapsulation 과 Decapsulation 중 전송 시
1. 한번에 보내는 적절한 프레임 바이트 수 (5,381, 1021 또는 full프레임)가 CS8900A 메모리에 전송되고 네트워크에 접속 할 수 있게 한다.
2. 이어서 MAC은 Start-of-Frame Delimiter(SFD, 10101011b)뒤에 7byte preamble(1010101b…)을 전송한다.
3. SFD와 FCS사이의 데이터는 host에서 공급된다. CS8900A가 제공하는 FCS 생성기는 inhibitCRC bit가 set 됨에 따라 비활성 된다.

- 프레임의 길이
![image](https://user-images.githubusercontent.com/30613069/186029692-d19a0309-fea5-4ee2-b585-0c962c4edc12.png)

- 프레임의 길이와 데이터의 길이
![image](https://user-images.githubusercontent.com/30613069/186029928-3a923a9f-ce1b-4e07-9c20-f1de857ced03.png)

## 칩의 레지스터
### 레지스터의 기본적인 접근 방법
1. PacketPage Pointer Port를 통해서 접근하며, 기본주소(base address)에 0x000A(ADD_PORT) 를 더해서 결정된다.
2. 레지스터에 있는 데이터를 읽기 위해서는 이 PacketPage Pointer Port에 먼저 레지스터의 offset을 쓰고 나서, data port를 통해서 읽어온다. 
3. 쓰는 것도 역시 PacketPage Pointer Port에 먼저 레지스터의 offset을 쓰고 나서, data port에 쓸 내용을 적어서 처리한다

## Packet Page Address
![image](https://user-images.githubusercontent.com/30613069/186030648-60dfdb44-5f0e-43be-91b9-e502548e9a74.png)
- Bus Interface Registers
  - ISA 버스를 이용하여 호스트시스템 혹은 I/O메모리에 맵핑 된다.
  - 초기 설정 후 작동 중에는 변경하지 않는다.
- Status and Control Registers
  - 레지스터의 상태를 얻거나 주요 제어를 한다.
- Initiate Transmit Registers
  - 이더넷 프레임을 전송할 때 초기화 시 사용한다.
- Address Filter Registers
  - 원격 주소 필터에 의해 사용된다.
- Receive and Transmit Frame Locations
  - 이더넷 프레임을 호스트로부터 전송할 때 사용한다.

### Packet Page 접근 예제
- Packet Page Pointer Port Register 를 통해 접근하는 방법
``` cmd
extern int inline readreg(struct net_device *dev, int portno)
{
outw(portno, dev->base_addr + ADD_PORT);
return inw(dev->base_addr + DATA_PORT);
}
extern void inline writereg(struct net_device *dev, int portno, int value)
{
outw(portno, dev->base_addr + ADD_PORT);
outw(value, dev->base_addr + DATA_PORT);
}
```

### 커널의 Network SubSystem
![image](https://user-images.githubusercontent.com/30613069/186266603-f9a4d20e-31f9-425b-a1ac-093d42afb56b.png)
1. 하드웨어에 정의된 레지스터들에 해당되는 주소들이 있음.
2. 네트워크 디바이스 드라이버에서 주소들을 정의. 정의된 주소를 통해서 처리할 수 있도록 내부에서 Read/Write 처리를 함
3. 드라이버를 통해 상위에 있는 Nework Subsystem : 운영체제가 갈 수 있는 일종의 Protocol Stack. 
### Network Protocol Stack
![image](https://user-images.githubusercontent.com/30613069/186267225-f982d800-20d9-47c7-8d93-8c2cf4fd5e40.png)

## 커널 부팅과 네트워크 디바이스 드라이버
- 커널 초기화 과정
  - 네트워크 디바이스 드라이버가 커널에 올라가 동작 대기
 
- 등록된 네트워크 디바이스 드라이버의 확인
  - cat /proc/net/dev : Receive, Transmit의 bytes, packets, errs, drop fifo frame..

- ifconfig 명령
  - 네트워크 디바이스를 활성화 하거나 비활성화 한다.
  - ifconfig [interface] [ip] [netmask mask] [up | down]
  - Ex) ifconfig eth0:0 192.168.19.191 netmask 255.255.255.0 up

## 네트워크 요소
- 인터페이스 이름
  - lo, dummy0, eth0 등과 같은 별칭을 사용 : lo는 루프백 어드레스로 127.0.0.1의 사용을 위한 논리적인 소프트웨어 주소
- 인터페이스 타입
  - ethernet, isdn, adsl과 같은 네트워크 형태
  - ifconfig -a 명령 시 Link encap 항목에서 확인
- 하드웨어 주소
  - 이더넷 하드웨어 MAC 주소
- 네트워크 주소
  - TCP/IP에서 사용을 위한 IP 주소
- 데이터 처리 능력
  - 한 프레임을 전송할 수 있는 데이터 량을 MTU라고 하고, 패킷을 전송할 때 분할 기준
  - 송신 시 네트워크 디바이스가 바쁠 때 시스템에 대기할 수 있는 큐의 크기는 txqueuelen으로 표시된다

## 네트워크 소켓
> 네트워크는 소켓으로 관리
- 소켓이라는 단일한 인터페이스로 묶어서 사용
- 네트워크를 초기화하여 다양한 통신 수단을 사용
- 운영체제의 파일시스템과 연동하여 구성
- 상위에서 보면 파일처럼 다루어지게 된다
- 소켓에서는 socket()과 bind() 라는 시스템콜 함수를 이용

